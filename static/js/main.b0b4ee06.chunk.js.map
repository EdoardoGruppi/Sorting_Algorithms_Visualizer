{"version":3,"sources":["SortingAlgorithms/MergeSort.js","SortingAlgorithms/QuickSort.js","SortingAlgorithms/HeapSort.js","SortingVisualizer/SortingVisualizer.jsx","SortingAlgorithms/BubbleSort.js","SortingAlgorithms/SelectionSort.js","SortingAlgorithms/InsertionSort.js","SortingAlgorithms/ShellSort.js","App.js","reportWebVitals.js","index.js"],"names":["performMergeSort","array","animations","length","arrayCopy","slice","mergeSortHelper","mainArray","start","end","middle","Math","floor","k","i","j","push","merge","quickSortHelper","pivotValue","pivotIndex","heapSortHelper","arrayLength","idx","largest","left","right","SortingVisualizer","props","state","bars","maximum","time","this","resetArray","min","max","new_value","random","includes","setState","newBars","document","getElementById","value","arrayBars","barOneIdx","barTwoIdx","swap","firstBarStyle","style","secondBarStyle","setTimeout","backgroundColor","height","getElementsByClassName","animation","newHeight","stack","pop","performQuickSort","displaySimpleAnimation","parseInt","performHeapSort","check","temp","performBubbleSort","performSelectionSort","prev","performInsertionSort","gap","performShellSort","id","map","className","width","display","type","step","defaultValue","onChange","resetBars","onClick","React","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b0b4ee06.chunk.js","sourcesContent":["export function performMergeSort(array) {\n  const animations = [];\n  // Base case or terminating case\n  if (array.length < 2) return array;\n  const arrayCopy = array.slice();\n  // Otherwise divide the array into two parts\n  mergeSortHelper(array, 0, array.length - 1, arrayCopy, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(mainArray, start, end, arrayCopy, animations) {\n  // Return if a given array has only one value\n  if (start === end) return;\n  const middle = Math.floor((start + end) / 2);\n  // Divide and operate recursively on the two halves of the passed array\n  mergeSortHelper(arrayCopy, start, middle, mainArray, animations);\n  mergeSortHelper(arrayCopy, middle + 1, end, mainArray, animations);\n  // Merge the two subarrays\n  merge(arrayCopy, start, middle, end, mainArray, animations);\n}\n\nfunction merge(arrayCopy, start, middle, end, mainArray, animations) {\n  let k = start;\n  let i = start;\n  let j = middle + 1;\n  // Compare the two subarrays and push the smaller element in the first position of the two arrays\n  // Do so until one of the two arrays has no items\n  while (i <= middle && j <= end) {\n    animations.push([i, j, 0]);\n    if (arrayCopy[i] <= arrayCopy[j]) {\n      animations.push([k, arrayCopy[i], 1]);\n      mainArray[k++] = arrayCopy[i++];\n    } else {\n      animations.push([k, arrayCopy[j], 1]);\n      mainArray[k++] = arrayCopy[j++];\n    }\n  }\n  // Push the remaining elements from one of the two array\n  // The while loop on the empty array is simply skipped\n  while (i <= middle) {\n    animations.push([k, arrayCopy[i], 1]);\n    mainArray[k++] = arrayCopy[i++];\n  }\n  while (j <= end) {\n    animations.push([k, arrayCopy[j], 1]);\n    mainArray[k++] = arrayCopy[j++];\n  }\n}\n","export function performQuickSort(array) {\n  // Animations list\n  const animations = [];\n  // Creating a stack of the elements to operate with\n  let stack = [];\n  // Adding the initial array as \"unsorted subarray\"\n  stack.push(0);\n  stack.push(array.length - 1);\n\n  // The loop is executed unitl the stack becomes empty\n  while (stack[stack.length - 1] >= 0) {\n    // Extracting the top unsorted subarray\n    let end = stack.pop();\n    let start = stack.pop();\n    // Find pivot index and move smaller number at the left and vice versa\n    let pivotIndex = quickSortHelper(array, start, end, animations);\n    // Add the unsorted subarray at the left of the pivot to the stack\n    if (pivotIndex - 1 > start) {\n      stack.push(start);\n      stack.push(pivotIndex - 1);\n    }\n    // Add the unsorted subarray at the right of the pivot to the stack\n    if (pivotIndex + 1 < end) {\n      stack.push(pivotIndex + 1);\n      stack.push(end);\n    }\n  }\n  return animations;\n}\n\nfunction quickSortHelper(array, start, end, animations) {\n  // Taking the last element as the pivot\n  const pivotValue = array[end];\n  // Cursor position starts from the beginning\n  let pivotIndex = start;\n\n  for (let i = start; i < end; i++) {\n    animations.push([i, end, 0]);\n    if (array[i] < pivotValue) {\n      // Swapping elements if the element is minor than the pivot.\n      // The objective is to have smaller number at the beginning.\n      animations.push([i, pivotIndex, 1]);\n      [array[i], array[pivotIndex]] = [array[pivotIndex], array[i]];\n      // For every item smaller than the pivot, increase the index where\n      // the pivot will be inserted at the end of the loop.\n      pivotIndex++;\n    }\n  }\n  // Move the pivot value in the middle according to how many\n  // smaller numbers have been found.\n  animations.push([end, pivotIndex, 1]);\n  [array[pivotIndex], array[end]] = [array[end], array[pivotIndex]];\n\n  return pivotIndex;\n}\n","export function performHeapSort(array) {\n  const animations = [];\n  let arrayLength = array.length;\n  // Build heap\n  for (let idx = parseInt(arrayLength / 2 - 1); idx >= 0; idx--) {\n    heapSortHelper(array, arrayLength, idx, animations);\n  }\n  // OIterate the elements strating from the last of them\n  for (let idx = arrayLength - 1; idx >= 0; idx--) {\n    // Swap current root with the end.\n    // Remember that when building the heap the biggest number\n    // has been moved into the initial position.\n    animations.push([0, idx, 1]);\n    [array[0], array[idx]] = [array[idx], array[0]];\n    // Call Helper function without considering items in position >= idx\n    heapSortHelper(array, idx, 0, animations);\n  }\n\n  return animations;\n}\n\nfunction heapSortHelper(array, arrayLength, idx, animations) {\n  // At the beginning consider the item at idx as largest\n  let largest = idx;\n  let left = 2 * idx + 1;\n  let right = 2 * idx + 2;\n  // Compare left child with the new root\n  if (left < arrayLength && array[left] > array[largest]) {\n    animations.push([left, largest, 0]);\n    largest = left;\n  }\n  // Compare right child with the new root\n  if (right < arrayLength && array[right] > array[largest]) {\n    animations.push([right, largest, 0]);\n    largest = right;\n  }\n  // Take the smallest child index and swap it with the root\n  if (largest !== idx) {\n    animations.push([largest, idx, 1]);\n    [array[largest], array[idx]] = [array[idx], array[largest]];\n    // Recursively compare the changed root with the other elements\n    heapSortHelper(array, arrayLength, largest, animations);\n  }\n}\n","import React from \"react\";\nimport \"./SortingVisualizer.css\";\nimport { performMergeSort } from \"../SortingAlgorithms/MergeSort\";\nimport { performBubbleSort } from \"../SortingAlgorithms/BubbleSort\";\nimport { performSelectionSort } from \"../SortingAlgorithms/SelectionSort\";\nimport { performInsertionSort } from \"../SortingAlgorithms/InsertionSort\";\nimport { performQuickSort } from \"../SortingAlgorithms/QuickSort\";\nimport { performHeapSort } from \"../SortingAlgorithms/HeapSort\";\nimport { performShellSort } from \"../SortingAlgorithms/ShellSort\";\n\nexport default class SortingVisualizer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      array: [],\n      bars: 100,\n      maximum: 1000,\n      time: 10,\n    };\n  }\n\n  // Function invoked as soon as a component is mounted\n  componentDidMount() {\n    this.resetArray();\n  }\n\n  // Creates an array of 100 values from 10 to 1000\n  resetArray() {\n    const array = [];\n    for (let i = 0; i < this.state.bars; i++) {\n      let new_value = randomIntFromInterval(10, this.state.maximum);\n      if (!array.includes(new_value)) {\n        // Start from 10 so to make it visible\n        array.push(new_value);\n      } else i--;\n    }\n    this.setState({ array: array });\n  }\n\n  resetBars() {\n    const newBars = document.getElementById(\"n_bars\").value;\n    this.setState({ bars: newBars }, () => {\n      this.resetArray();\n    });\n  }\n\n  displaySimpleAnimation(arrayBars, animations) {\n    for (let i = 0; i < animations.length; i++) {\n      const [barOneIdx, barTwoIdx, swap] = animations[i];\n      const firstBarStyle = arrayBars[barOneIdx].style;\n      const secondBarStyle = arrayBars[barTwoIdx].style;\n      // Colour the compared bars in red\n      setTimeout(() => {\n        firstBarStyle.backgroundColor = \"red\";\n        secondBarStyle.backgroundColor = \"red\";\n      }, i * this.state.time);\n      // Swap the bars only if required\n      if (swap) {\n        setTimeout(() => {\n          [firstBarStyle.height, secondBarStyle.height] = [\n            secondBarStyle.height,\n            firstBarStyle.height,\n          ];\n        }, (i + 0.5) * this.state.time);\n      }\n      // Convert the bars colour to the original state\n      setTimeout(() => {\n        firstBarStyle.backgroundColor = \"yellow\";\n        secondBarStyle.backgroundColor = \"yellow\";\n      }, (i + 1) * this.state.time);\n    }\n  }\n\n  mergeSort() {\n    let max = Math.max(...this.state.array);\n    const arrayBars = document.getElementsByClassName(\"array-bar\");\n    const animations = performMergeSort(this.state.array);\n    for (let i = 0; i < animations.length; i++) {\n      let animation = animations[i];\n      if (animation[2]) {\n        const [barOneIdx, newHeight] = animation;\n        setTimeout(() => {\n          arrayBars[barOneIdx].style.backgroundColor = \"red\";\n          arrayBars[barOneIdx].style.height = `${(newHeight / max) * 87}vh`;\n        }, i * this.state.time);\n        setTimeout(() => {\n          arrayBars[barOneIdx].style.backgroundColor = \"yellow\";\n        }, (i + 1) * this.state.time);\n      } else {\n        setTimeout(() => {\n          arrayBars[animation[0]].style.backgroundColor = \"red\";\n          arrayBars[animation[1]].style.backgroundColor = \"red\";\n        }, i * this.state.time);\n        setTimeout(() => {\n          arrayBars[animation[0]].style.backgroundColor = \"yellow\";\n          arrayBars[animation[1]].style.backgroundColor = \"yellow\";\n        }, (i + 1) * this.state.time);\n      }\n    }\n  }\n\n  quickSort() {\n    const arrayBars = document.getElementsByClassName(\"array-bar\");\n    const animations = performQuickSort(this.state.array);\n    this.displaySimpleAnimation(arrayBars, animations);\n  }\n\n  heapSort() {\n    const arrayBars = document.getElementsByClassName(\"array-bar\");\n    const animations = performHeapSort(this.state.array);\n    this.displaySimpleAnimation(arrayBars, animations);\n  }\n\n  bubbleSort() {\n    const arrayBars = document.getElementsByClassName(\"array-bar\");\n    const animations = performBubbleSort(this.state.array);\n    this.displaySimpleAnimation(arrayBars, animations);\n  }\n\n  selectionSort() {\n    const arrayBars = document.getElementsByClassName(\"array-bar\");\n    const animations = performSelectionSort(this.state.array);\n    this.displaySimpleAnimation(arrayBars, animations);\n  }\n\n  insertionSort() {\n    const arrayBars = document.getElementsByClassName(\"array-bar\");\n    const animations = performInsertionSort(this.state.array);\n    this.displaySimpleAnimation(arrayBars, animations);\n  }\n\n  shellSort() {\n    const arrayBars = document.getElementsByClassName(\"array-bar\");\n    const animations = performShellSort(this.state.array);\n    this.displaySimpleAnimation(arrayBars, animations);\n  }\n\n  render() {\n    const { array } = this.state;\n    let max = Math.max(...array);\n\n    return (\n      <div id=\"array-container\">\n        {array.map((value, idx) => (\n          <div\n            className=\"array-bar\"\n            key={idx}\n            style={{\n              height: `${(value / max) * 87}vh`,\n              // The margin between bars is considered as well\n              width: `${(87 - 0.15 * this.state.bars) / this.state.bars}vw`,\n            }}\n          ></div>\n        ))}\n        <div>\n          <div style={{ display: \"inline-block\" }}>\n            <span className=\"rangeValue\">BARS: {this.state.bars}</span>\n            <input\n              className=\"range\"\n              id=\"n_bars\"\n              type=\"range\"\n              min=\"5\"\n              step=\"5\"\n              defaultValue=\"100\"\n              max=\"200\"\n              onChange={() => this.resetBars()}\n            ></input>\n          </div>\n          <div style={{ display: \"inline-block\" }}>\n            <span className=\"rangeValue\">SPEED: {this.state.time} ms</span>\n            <input\n              className=\"range\"\n              id=\"speed\"\n              type=\"range\"\n              min=\"1\"\n              step=\"1\"\n              defaultValue=\"10\"\n              max=\"1000\"\n              onChange={() =>\n                this.setState({ time: document.getElementById(\"speed\").value })\n              }\n            ></input>\n          </div>\n          <button\n            className=\"button_slide slide_down\"\n            onClick={() => this.resetArray()}\n          >\n            NEW ARRAY\n          </button>\n          <select\n            id=\"select_box\"\n            className=\"box slide_down\"\n            onChange={() => {\n              let value = document.getElementById(\"select_box\").value;\n              if (value !== \"default\") this[value]();\n            }}\n            defaultValue=\"default\"\n          >\n            <option value=\"default\">ALGORITHM</option>\n            <option value=\"bubbleSort\">BUBBLE SORT</option>\n            <option value=\"quickSort\"> QUICK SORT </option>\n            <option value=\"heapSort\">HEAP SORT</option>\n            <option value=\"mergeSort\">MERGE SORT</option>\n            <option value=\"selectionSort\">SELECTION SORT</option>\n            <option value=\"insertionSort\">INSERTION SORT</option>\n            <option value=\"shellSort\">SHELL SORT</option>\n          </select>\n        </div>\n      </div>\n    );\n  }\n}\n\n// Function to generate random numbers from min to max, both inclusive\nfunction randomIntFromInterval(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","export function performBubbleSort(array) {\n  const animations = [];\n  let check = true;\n  // Perform this loop until no swap occurs in the entire while body\n  while (check) {\n    // Variable useful to understand when two items swap\n    check = false;\n    for (let idx = 0; idx < array.length - 1; idx++) {\n      // The swap happens only if an element is greater than that one position after\n      if (array[idx] > array[idx + 1]) {\n        animations.push([idx, idx + 1, 1]);\n        let temp = array[idx];\n        array[idx] = array[idx + 1];\n        array[idx + 1] = temp;\n        check = true;\n      } else {\n        animations.push([idx, idx + 1, 0]);\n      }\n    }\n  }\n  return animations;\n}\n","export function performSelectionSort(array) {\n  const animations = [];\n  for (let i = 0; i < array.length; i++) {\n    // For every iteration find the minimum element in the array\n    let min = i;\n    // Cycle to find the minimum\n    for (let j = i + 1; j < array.length; j++) {\n      animations.push([i, min, 0]);\n      if (array[j] < array[min]) {\n        min = j;\n      }\n    }\n    animations.push([i, min, 0]);\n    // Swap the item in the current position with the minimum one only\n    // if they do not correspond to the same element.\n    if (min !== i) {\n      animations.push([i, min, 1]);\n      let temp = array[i];\n      array[i] = array[min];\n      array[min] = temp;\n    }\n  }\n  return animations;\n}\n","export function performInsertionSort(array) {\n  const animations = [];\n\n  for (let idx = 1; idx < array.length; idx++) {\n    let temp = array[idx];\n    let prev = idx - 1;\n    // Move at the left the current item unitl it succeeds only smaller numbers\n    while (prev > -1 && temp < array[prev]) {\n      // Perform the swap between the two compared items\n      animations.push([prev, prev + 1, 1]);\n      [array[prev + 1], array[prev]] = [array[prev], array[prev + 1]];\n      prev--;\n    }\n  }\n  return animations;\n}\n","export function performShellSort(array) {\n  const animations = [];\n  const arrayLength = array.length;\n\n  // It works as the insetion sort algorithm performed using decreasing intervals\n  // Rearrange elements at each n/2, n/4, n/8, ... intervals\n  let gap = Math.floor(arrayLength / 2);\n  while (gap > 0) {\n    for (let idx = gap; idx < array.length; idx++) {\n      let temp = array[idx];\n      let prev = idx - gap;\n      // Move at the left the current item unitl it succeeds only smaller numbers\n      while (prev > -1 && temp < array[prev]) {\n        animations.push([idx, prev, 0]);\n        // Perform the swap between the two compared items\n        animations.push([prev, prev + gap, 1]);\n        [array[prev + gap], array[prev]] = [array[prev], array[prev + gap]];\n        prev -= gap;\n      }\n    }\n    gap = Math.floor(gap / 2);\n  }\n\n  return animations;\n}\n","import \"./App.css\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}